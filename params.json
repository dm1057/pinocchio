{"name":"Pinocchio","tagline":"Git based server provisioning.","body":"# [Pinocchio] - A git puppet.\r\n\r\nA minimalist tool for Git based server provisioning.\r\n\r\n![Pinocchio](https://gist.github.com/vic/3494d261c68cb3b591e6/raw/acdbcdeb06606ee8a833e992e135bec6db34ecac/pinocchio.jpg)\r\n\r\n### Why?\r\n\r\nServer configuration and software provisioning should be damn simple.\r\n\r\nThere are lots of tools for helping you install and configure your\r\nfull software stack at your new and shiny cloud based slice. Just to name\r\na few, we have [Puppet], [Chef], and the [Capistrano] based [Sprinkle].\r\nAll of them trying to solve the problem of automating software installation\r\nand configuration on many servers. Basically you write a _recipe_ file \r\ncontaining instructions on how to install or configure something, some of\r\nthese recipes require you to learn their respective mini/dsl language, \r\nsome of them even require you to host those recipes on a service of their\r\nown.\r\nSure these tools all have their own merit and can be useful when managing\r\nlots of servers, but for me, they were sometimes just like too much complex\r\nwhen I just wanted to provision a new slice to get more fun at coding a \r\nnew experiment.\r\n\r\nI just wanted to have some dead simple way of uploading a new configuration\r\nfile or instructions for the server on how to install something. I wanted to\r\ndeliver these just like I'm used with regular code, by using git. \r\nI wanted to push and see *only* the new pending instructions being executed\r\non my remote slices. I wanted to have all of it versioned and under control.\r\nI wanted these changes to be incremental, something like using rails database\r\nmigrations but for provisioning my servers.\r\n\r\nSo [Pinocchio] was born.\r\n\r\n### How it works\r\n\r\n[Pinocchio] is just a simple git `update` hook. It works by determining which\r\nchanges it needs to execute since the last successful update. \r\nIt does it by leveraging on git to know which *migrations* need to be run, \r\nand only when _*all*_ of these pending migrations have a successful exit status\r\nthe git repo is updated.\r\n\r\n### Installation\r\n\r\nTo use [Pinocchio] on your remote server, all you need is for it to have\r\ngit installed and the pinocchio's update hook configured at a bare repo.\r\n\r\nIn the following examples we assume the remote repo is hosted at \r\n*my-new-slice* with user *ubuntu* at the *~/pinocchio* directory.\r\n\r\n###### Automated setup on server\r\n\r\nThe `pinocchio install` command can automatically setup Pinocchio for you\r\non your remote server. In essence it just checks that git is installed\r\nor installs it for you if it can and then creates a new git bare repo at\r\nthe specified directory, copying pinocchio's update hook and making it\r\nexecutable.\r\n\r\n```shell\r\n$ git clone https://github.com/vic/pinocchio.git && cd pinocchio\r\n$ bin/pinocchio install '~/pinocchio' ubuntu@my-new-slice\r\n```\r\n\r\n###### Manual setup on server\r\n\r\n```shell\r\n# install git unless you already have it on your remote server\r\n$ ssh ubuntu@my-new-slice 'sudo apt-get install git'\r\n\r\n# create a remote repo for pinocchio and install the update hook\r\n$ cat hooks/pinocchio | ssh ubuntu@my-new-slice 'git init --bare ~/pinocchio && cat -> ~/pinocchio/hooks/update && chmod 755 ~/pinocchio/hooks/update'\r\n```\r\n\r\n### Usage\r\n\r\nClone [Pinocchio] into a local directory on your computer, and edit\r\nyour remotes accordingly, for our previous ubuntu example it would be:\r\n\r\n```shell\r\n$ git remote --set-url origin ubuntu@my-new-slice:~/pinocchio\r\n```\r\n\r\nOf course you can create as many remotes as you wish to provision with\r\nyour repo.\r\n\r\n###### Creating migration scripts\r\n\r\nAfter cloning your local pinocchio, you can create your provisioning\r\n*migrations* under the `migrate/` directory. \r\n\r\n```\r\nREADME.md\r\nmigrate/\r\n        201311051205-install-mysql.sh\r\n```\r\n\r\n[Pinocchio] migrations are language agnostic, they can be just shell scripts\r\nas well as python or ruby scripts or whatever your server can execute. \r\nThe only requirement for them is _to be executables_ and exit with *zero status* when successful.\r\n\r\nI highly recommend to prefix the migration files with a timestamp as Pinocchio\r\n will try to run them in natural order.\r\nTo aid with timestamps you can use the `pinocchio generate` command:\r\n\r\n```shell\r\n$ bin/pinocchio generate install-mysql.sh\r\n  Generated migrate/201311051205-install-mysql.sh\r\n```\r\n\r\n###### Configuration files\r\n\r\n[Pinocchio] provides a `files/` directory where you can place any\r\nfile that will be copied into your servers filesystem whenever it changes.\r\n\r\n```\r\nREADME.md\r\nmigrate/\r\n        201311051215-install-nginx.sh\r\nfiles/\r\n        etc/\r\n             nginx.conf\r\n```\r\n\r\nFiles are copied only after the pending migrations have finished\r\nsuccessfully. So for example, when the *install-nginx* migration \r\nfinishes, the `files/etc/nginx.conf` file gets copied into `/etc/nginx.conf`.\r\n\r\nNote that Pinocchio makes no attempt at creating the directory\r\nstructure, it simply copies the files and expects the migrations\r\nto have already prepared everything else.\r\n\r\n\r\n###### User permissions\r\n\r\nSometimes you'd want the migration scripts to be executed as a\r\nparticular user or the copied files to have some particular owner.\r\n\r\n[Pinocchio] supports specifying user/group permissions for both\r\nmigration scripts and copied files. You specify them with the\r\n`pinocchio user` and `pinocchio group` commands.\r\n\r\n```\r\nREADME.md\r\nmigrate/\r\n        201311051230-create-rails-user.sh\r\n        201311051231-install-rails-rvm.sh\r\nfiles/\r\n      home/\r\n           rails/\r\n                 .bashrc\r\n```\r\n\r\nWe want the migration for creating a user to be run as root, \r\nand the migration to install rvm to be run as the rails user.\r\nWe also specify the owner for the bashrc file.\r\n\r\n```shell\r\n$ bin/pinocchio user root  migrate/201311051230-create-rails-user.sh\r\n$ bin/pinocchio user rails migrate/201311051231-install-rails-rvm.sh\r\n$ bin/pinocchio user rails files/home/rails/.bashrc\r\n```\r\n\r\n###### Updating your remote servers\r\n\r\n[Pinocchio] lets you manage incremental changes on your server as\r\na simple git repo. So, after you've written some migration scripts\r\nat `migrate/` or placed some configuration files under `files/` all\r\nyou need if to simply make a `git push` and the pinocchio's update\r\nhook will take care of performing pending actions and updating files.\r\n\r\nIf all migrations run successfully, the code is updated and next time only\r\nnew migrations will be executed.\r\n\r\n### Contributing\r\n\r\nFeel free to contribute issues, ideas, pull-requests to [http://github.com/vic/pinocchio/issues](http://github.com/vic/pinocchio/issues) \r\n\r\n### Testimonials\r\n\r\n> Just another puppet who loves using this simple tool to improve their infrastructure and development process:\r\n>\r\n![Infraestructur](https://gist.github.com/vic/3494d261c68cb3b591e6/raw/ab4c364f0016fc2f041b86dd842c07515d5dc758/infraestructur.png)\r\n![Development process](https://gist.github.com/vic/3494d261c68cb3b591e6/raw/505e8b0cc8c3515810d26750da90cd9df11b0e00/development.png)\r\n\r\n\r\n### License\r\n\r\nMIT\r\n\r\n[Puppet]: http://puppetlabs.com\r\n[Chef]: http://docs.opscode.com/index.html\r\n[Capistrano]: http://www.capistranorb.com/\r\n[Sprinkle]: https://github.com/sprinkle-tool/sprinkle\r\n[Pinocchio]: http://github.com/vic/pinocchio\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}